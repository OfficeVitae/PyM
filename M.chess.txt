; arguments: player1 and player2
$=0 ; assume no winner
(debugnow=debug,debug=0) ; disable debugging
piecetypes='PRNBQK' ; characters to use (pawn, rook, knight, bishop, queen and king)
piecetypenames=('pawn','rook','knight','bishop','queen','king') ; the names of the piece (types)
movecharacters='abcdefghijklmnopqrstuvwxyz.,' ; the characters to use for marking the piece positions on the board that can be moved
ranges=l(8..1,1..8) ; display ranges
colors=l(231,16) ; the (foreground) color of the pieces
bgcolors=l(247,251) ; the field colors
shadowcolors=l(249,249) ; the gray next to the field colors
; initialize the game
rows='12345678' ; the row names
cols='abcdefgh' ; the column names
movecount=0
enpassantcols=l(?,?) ; keep track of the en passant capture positions (which is always the position behind a two-step pawn movement)
playerindex=2 ; current player
; keep track of the positions of all pieces (by player, by type)
; if we always store the position of the king in the first element, it's easy to find
; and the nearest rook in the second position, and the farthest rook in the third position to make it easy to check whether they moved
piecepositions=l(
  l(l(6,1,5,0),l(2,1,8,0),l(2,1,1,0),l(3,1,2,0),l(4,1,3,0),l(5,1,4,0),l(4,1,6,0),l(3,1,7,0),l(1,2,1,0),l(1,2,2,0),l(1,2,3,0),l(1,2,4,0),l(1,2,5,0),l(1,2,6,0),l(1,2,7,0),l(1,2,8,0)),
  l(l(6,8,5,0),l(2,8,8,0),l(2,8,1,0),l(3,8,2,0),l(4,8,3,0),l(5,8,4,0),l(4,8,6,0),l(3,8,7,0),l(1,7,1,0),l(1,7,2,0),l(1,7,3,0),l(1,7,4,0),l(1,7,5,0),l(1,7,6,0),l(1,7,7,0),l(1,7,8,0))
  )
; put the pieces on the board
board=replicate(replicate(0,8),8) ; create empty board
for(pi,1..2,ppps=piecepositions(pi),for(ppi,1..len(ppps),pps=ppps(ppi),out("pps#",ppi,":",pps,".",lf),board(pps(2),pps(3))=if(pi==1,pps(1),-pps(1)),out("board(",pps(2),",",pps(3),")=",board(pps(2),pps(3)),".",lf)))
;;out("Board now: ",board,".",lf)
; initialize check pieces (the positions on the board from where pieces can give check)
; NOTE that at the start of the game there are no check fields
(checkpieces,incheckinfo) ; declare
if(debug&1,out(lf))
; PREPARE FOR ACCEPTING A MOVE
playerindex=3-playerindex
out(if(playerindex==1,player1,player2),", it's your turn.",lf)
updateCheckPieces() ; collect (in) check information
; determine all valid moves the current player can do
validmoves=getValidPlayerMoves(playerindex)
;;out("Valid moves: ",validmoves,lf)
; determine the positions of the pieces that can be moved, and count the number of possible moves
(validmovecount=0,piecemovecharacters='',movablepieceindices=l(),movablepiecepositions=l(),
  for(validmoveindex,1..len(validmoves)
     ,lvm=len(validmoves(validmoveindex))
     ,if(lvm>0
        ,(validmovecount+=lvm
         ,pmc=movecharacters(len(movablepiecepositions)+1)
         ,piecemovecharacters+=pmc
         ,movablepieceindices.=l(validmoveindex)
         ,movablepiecepositions.=l(l(piecepositions(playerindex,validmoveindex,2),piecepositions(playerindex,validmoveindex,3),pmc))
         )
        )
     )
  )
;;out("Movable piece indices: ",movablepieceindices,lf)
; show chess board in the orientation of the current player
out("Chess board after ",movecount," moves.",lf)
showBoard(movablepiecepositions,colors(playerindex))

; CHECK FOR CHECK MATE
; if there are no pieces that can move, the opponent won, otherwise show how many moves one can make!!!
if(validmovecount==0,(debug=debugnow,return(3-playerindex)),out("Number of valid moves: ",validmovecount,".",lf))
; ASK THE CURRENT PLAYER FOR THE PIECE TO MOVE
(out(if(playerindex==1,player1,player2)+', what piece do you want to move ['+piecemovecharacters+']? '),piececharacterindex=inch(piecemovecharacters),out(piececharacterindex,lf)) ; get one of the player pieces characters
if(piececharacterindex<=0,if(givingUp(),(debug=debugnow,return(3-playerindex)),jump(-1))) ; if no piece defined, ask the user if they want to give up
; the piecetype is either a column name (a-h) or the type of one of the pieces
; get the position of this piece, if multiple positions exist, ask the user which one he means, there can be at most 8 of them (pawns), which we may number
pieceindex=movablepieceindices(piececharacterindex) ; returns the index of the piece to move (so piecepositions(playerindex,pieceindex,(2,3)) is the start position)
;;out("Piece index=",pieceindex,lf)
piecemoveto=getMoveTo(pieceindex,piecepositions(playerindex,pieceindex,1),colors(playerindex)) ; where to move the piece to (marking the options in the player color!!)
out("Position to move to=",piecemoveto,lf)
; EXECUTE THE MOVE
(fromrow=piecepositions(playerindex,pieceindex,2),fromcol=piecepositions(playerindex,pieceindex,3),torow=piecemoveto(1),tocol=piecemoveto(2))
out("Moving your ",piecetypenames(piecetypeindex)," at ",cols(fromcol),rows(fromrow)," to ",cols(tocol),rows(torow),".",lf)
plsign=3-2*playerindex
movecount+=1
(captured=abs(board(torow,tocol)),board(torow,tocol)=plsign*piecepositions(playerindex,pieceindex,1),board(fromrow,fromcol)=0) ; perform the move on the board
; register the new position and increment the number of moves made by the moved piece
(piecepositions(playerindex,pieceindex,2)=torow,piecepositions(playerindex,pieceindex,3)=tocol,piecepositions(playerindex,pieceindex,4)+=1)
; don't forget to remove the piece of the opponent that was captured by negating it's type, but first we need to find it
; SPECIAL CASE 1. if a pawn moves two rows the first time, we have to make it en passant capturable
if(and(piecetypeindex==1,abs(fromrow-torow)==2),enpassantcols(playerindex)=fromcol)
; SPECIAL CASE 2. castling (short: torow will equal 7, long: torow will equal 3)
; NOTE we're moving the rook but not counting that as a move (because the king also moved, castling won't be possible anymore anyway)
if(and(piecetypeindex==6,abs(fromcol-tocol)==2)
  ,if(tocol==7
     ,(board(torow,8)=0,board(torow,6)=plsign*2,piecepositions(playerindex,2,3)=6)
     ,(board(torow,1)=0,board(torow,4)=plsign*2,piecepositions(playerindex,3,3)=4)
     )
  )
; SPECIAL CASE 3. pawn promotion (let's promote to a queen for now automatically)
if(and(piecetypeindex==1,torow==if(playerindex==1,8,1)),(board(torow,tocol)=plsign*5,piecepositions(playerindex,pieceindex,1)=5))
; SPECIAL CASE 4. in the case of an en passant capture move, the pawn that was on the from row needs to be removed!!!
if(and(captured==0,piecetypeindex==1,fromcol!=tocol),(captured=1,torow=fromrow,board(torow,tocol)==0))
enpassantcols(3-playerindex)=? ; no matter what move was done there won't be a enpassant col of the opponent any more
if(captured>0,(opponentindex=3-playerindex,pieceindex=16,notfound=1
              ,while(and(pieceindex>0,notfound)
                    ,if(and(piecepositions(opponentindex,pieceindex,1)==captured,piecepositions(opponentindex,pieceindex,2)==torow,piecepositions(opponentindex,pieceindex,3)==tocol)
                       ,(piecepositions(opponentindex,pieceindex,1)=-captured,notfound=0)
                       ,pieceindex-=1
                       )
                    )
              )
  )
out("Piece positions: ",piecepositions,lf) ; for debugging purposes
jump(-71+8+5+11) ; take all continuations into account!!!
