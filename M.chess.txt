; arguments: player1 and player2
$=0 ; assume no winner
(debugnow=debug,debug=0) ; disable debugging
piecetypes='PRNBQK' ; characters to use (pawn, rook, knight, bishop, queen and king)
piecetypenames=l('pawn','rook','knight','bishop','queen','king') ; the names of the piece (types)
playertypes=l('white','black') ; the player 'types'
movecharacters='abcdefghijklmnopqrstuvwxyz.,' ; the characters to use for marking the piece positions on the board that can be moved
moveeffectcharacters=l('+','=','#') ; characters for representing the effect of the last move (of the opponent), i.e. 1=check, 2=draw, 3=mate
movetypecolors=l(20,200,201,33,226) ; the move type colors used by showBoard() 1=normal, 2=short castling, 3=long castling, 4=two step pawn, 5=en passant capture
ranges=l(8..1,1..8) ; display ranges
colors=l(231,16) ; the (foreground) color of the pieces
bgcolors=l(247,251) ; the field colors
shadowcolors=l(249,249) ; the grays close to the field colors for showing the row and column name in each field
; initialize the game
rows='12345678' ; the row names
cols='abcdefgh' ; the column names
(movecount=0,moveeffect=0) ; the move effect represents the effect of the last move (0='no',1=check,2=draw (not in check, but can't move),3=mate)
playerindex=1 ; current player
(drawoffered=0,moveslefttodrawclaim=100) ; things that have to do with offering or claiming a draw
; keep track of the positions of all pieces (by player, by type)
; if we always store the position of the king in the first element, it's easy to find
; and the nearest rook in the second position, and the farthest rook in the third position to make it easy to check whether they moved
piecepositions=l(
  l(l(6,1,5,0),l(2,1,8,0),l(2,1,1,0),l(3,1,2,0),l(4,1,3,0),l(5,1,4,0),l(4,1,6,0),l(3,1,7,0),l(1,2,1,0),l(1,2,2,0),l(1,2,3,0),l(1,2,4,0),l(1,2,5,0),l(1,2,6,0),l(1,2,7,0),l(1,2,8,0)),
  l(l(6,8,5,0),l(2,8,8,0),l(2,8,1,0),l(3,8,2,0),l(4,8,3,0),l(5,8,4,0),l(4,8,6,0),l(3,8,7,0),l(1,7,1,0),l(1,7,2,0),l(1,7,3,0),l(1,7,4,0),l(1,7,5,0),l(1,7,6,0),l(1,7,7,0),l(1,7,8,0))
  )
;;out("Initial piece positions: ",piecepositions,lf)
; put the pieces on the board
board=replicate(replicate(0,8),8) ; create empty board
for(pi,1..2,ppps=piecepositions(pi),for(ppi,1..len(ppps),pps=ppps(ppi),board(pps(2),pps(3))=if(pi==1,pps(1),-pps(1))))
(boardstates=l(),canshortcastle=l(0,0),canlongcastle=l(0,0),enpassantcols=l(0,0)) ; to allow claiming a draw when a board state is replicated for the third time we have to keep track of the board states
if(debugnow&1,out(lf))
remoteplayerindex=0 ; no remote player
; PREPARE FOR ACCEPTING A MOVE
;;out(if(playerindex==1,player1,player2),", it's your turn now.",lf)
if(playerindex==remoteplayerindex,(rpm=getRemotePlayerMove(),pieceindex=rpm(1),piecemoveto=l(rpm(2),rpm(3),rpm(4),rpm(5)),jump(40)))
if(movecount>0,out("Chess board after ",movecount," moves:",lf))
; determine all valid moves the current player can do (iff the game hasn't ended in a draw (moveeffect=2) or mate (moveeffect=3)
; determine the positions of the pieces that can be moved, and count the number of possible moves
; we also determine if a certain piece can check the opponent with one of its moves
movablepiecepositions=l()
if(moveeffect<2
  ,(validmoves=getValidPlayerMoves(),
   ,validmovecount=0,piecemovecharacters='',movablepieceindices=l(),movablepiecepositions=l(),
    for(validmoveindex,1..len(validmoves)
       ,lvm=len(validmoves(validmoveindex))
       ,if(lvm>0
          ,(validmovecount+=lvm
           ,pmc=movecharacters(len(movablepiecepositions)+1)
           ,piecemovecharacters+=pmc
           ,movablepieceindices.=l(validmoveindex)
           ,checkormate=0,anydraw=0,piecemoveindex=lvm
           ,while(piecemoveindex>0,select(validmoves(validmoveindex,piecemoveindex,4),,if(checkormate==0,checkormate=2),anydraw=1,checkormate=4),piecemoveindex-=1)
           ,movablepiecepositions.=l(l(piecepositions(playerindex,validmoveindex,2),piecepositions(playerindex,validmoveindex,3),anydraw+checkormate,pmc))
           )
          )
       )
    )
  )
;;out("Movable piece indices: ",movablepieceindices,lf)
; show chess board in the orientation of the current player
showBoard(movablepiecepositions,colors(playerindex))
; if DRAW OR CHECK MATE EXIT
if(moveeffect==2,return(0),if(moveeffect==3,return(3-playerindex)))
; ACCEPT THE DRAW OFFER OF THE OPPONENT?
if(drawoffered,(out("Would you agree to a draw [yn]? "),if(inch('yn')==1,return(0))))
; ASK THE CURRENT PLAYER FOR THE PIECE TO MOVE
(out(if(playerindex==1,player1,player2)+', what piece do you want to move ['+piecemovecharacters+']? '),piececharacterindex=inch(piecemovecharacters),out(lf)) ; get one of the player pieces characters
if(piececharacterindex<=0,if(givingUp(),(debug=debugnow,return(3-playerindex)),jump(-1))) ; if no piece defined, ask the user if they want to give up
; the piecetype is either a column name (a-h) or the type of one of the pieces
; get the position of this piece, if multiple positions exist, ask the user which one he means, there can be at most 8 of them (pawns), which we may number
pieceindex=movablepieceindices(piececharacterindex) ; returns the index of the piece to move (so piecepositions(playerindex,pieceindex,(2,3)) is the start position)
piecetypeindex=piecepositions(playerindex,pieceindex,1) ; the type of the piece being moved
;;out("Piece index=",pieceindex," - type=",piecetypeindex,lf)
(fromrow=piecepositions(playerindex,pieceindex,2),fromcol=piecepositions(playerindex,pieceindex,3),piecemoveto=getMoveTo(pieceindex,piecetypeindex,colors(playerindex),fromrow,fromcol)) ; where to move the piece to (marking the options in the player color!!)
if(len(piecemoveto)==0,jump(-14)) ; start over (showing the board again!)
;;out("Position to move to=",piecemoveto,lf)
; EXECUTE THE MOVE
(torow=piecemoveto(1),tocol=piecemoveto(2))
out("Moving the ",playertypes(piecetypeindex)," ",piecetypenames(piecetypeindex)," at ",cols(fromcol),rows(fromrow)," to ",cols(tocol),rows(torow),".",lf)
plsign=3-2*playerindex
pawnmoved=(abs(board(fromrow,fromcol))==1)
(movetype=piecemoveto(3),moveeffect=piecemoveto(4),movecount+=1) ; increment the move count, and remember the 'effect' of the move (1=checks, 2=draw, 3=mate, 0=not in check, can move)
(captured=abs(board(torow,tocol)),board(torow,tocol)=plsign*piecetypeindex,board(fromrow,fromcol)=0) ; perform the move on the board
; register the new position and increment the number of moves made by the moved piece
(piecepositions(playerindex,pieceindex,2)=torow,piecepositions(playerindex,pieceindex,3)=tocol,piecepositions(playerindex,pieceindex,4)+=1)
;;out("Moved piece: player=",playerindex," piece=",pieceindex," info=",piecepositions(playerindex,pieceindex),".",lf)
; don't forget to remove the piece of the opponent that was captured by negating it's type, but first we need to find it
; SPECIAL MOVE TYPES
; 2. short castling
; 3. long castling
; 4. if a pawn moves two rows the first time (as indicated by the move type), we have to make it en passant capturable
; 5. en passant capture
if(movetype!=1
  ,(out("Type of move: ")
   ,select(movetype,out("invalid"),
           ,(out("short castling"),board(torow,8)=0,board(torow,6)=plsign*2,piecepositions(playerindex,2,3)=6)
           ,(out("long castling"),board(torow,1)=0,board(torow,4)=plsign*2,piecepositions(playerindex,3,3)=4)
           ,(out("pawn double step"),enpassantcols(playerindex)=fromcol)
           ,(out("en passant capture"),captured=1,torow=fromrow,board(torow,tocol)=0)
           )
    ,out(".",lf)
    )
  )
if(moveeffect>0,(out("Effect of move: "),select(moveeffect,,out("check"),out("draw"),out("check and mate")),out(".",lf)))
enpassantcols(3-playerindex)=0 ; no matter what move was done there won't be a enpassant col of the opponent any more
if(captured>0,(moveslefttodrawclaim=100
              ,opponentindex=3-playerindex,pieceindex=16,notfound=1
              ,while(and(notfound!=0,pieceindex>0)
                    ,if(and(piecepositions(opponentindex,pieceindex,1)==captured,piecepositions(opponentindex,pieceindex,2)==torow,piecepositions(opponentindex,pieceindex,3)==tocol)
                       ,(notfound=0,piecepositions(opponentindex,pieceindex,1)=-captured)
                       ,pieceindex-=1
                       )
                    )
              )
             ,if(pawnmoved
                ,(moveslefttodrawclaim=100)
                ,(moveslefttodrawclaim-=1
                 ,if(moveslefttodrawclaim<=0
                    ,(out("At least 50 moves without moving a pawn or capturing a piece have passed! Do you want to claim a draw [yn]?")
                     ,if(inch('yn')==1,moveeffect=2)
                    )
                   )
                  )
                )
  )
;;out("Board: ",board,lf,"Piece positions: ",piecepositions,lf) ; for debugging purposes
if(and(moveeffect!=1,moveeffect!=3),(out("Do you want to offer your opponent a draw? "),drawoffered=(inch('yn')==1),out(lf)))
playerindex=3-playerindex
; update special move flags (the board of course, and whether or not the player could castle or capture en passant
if(and(moveeffect==0,piecepositions(playerindex,1,4)==0)
  ,(krow=piecepositions(playerindex,1,2),kcol=piecepositions(playerindex,1,3),ksign=3-2*playerindex
   ,canshortcastle(playerindex)=and(piecepositions(playerindex,2,4)==0,board(krow,6)==0,board(krow,7)==0,attacks(-ksign,krow,6)==0,attacks(-ksign,krow,7)==0,attacks(-ksign,krow,8)==0)
   ,canlongcastle(playerindex)=and(piecepositions(playerindex,3,4)==0,board(krow,2)==0,board(krow,3)==0,board(krow,4)==0,attacks(-ksign,krow,4)==0,attacks(-ksign,krow,3)==0,attacks(-ksign,krow,1)==0)
   )
  ,(canshortcastle(playerindex)=0,canlongcastle(playerindex)=0)
  )
;;out("Current state: En passant capture column=",enpassantcols(3-playerindex)," - short castling=",if(canshortcastle(playerindex),"yes","no")," - long castling=",if(canlongcastle(playerindex),"yes","no"),".",lf)
boardstate=l(board,canshortcastle,canlongcastle,enpassantcols) ; the information we need to store in order to be able to recognize the same state
boardstates.=l(boardstate)
jump(-105+6+19+10+17) ; take all continuations into account!!!
