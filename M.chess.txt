; arguments: player1 and player2
$=0 ; assume no winner
(debugnow=debug,debug=0) ; disable debugging
piecetypes='PRNBQK' ; characters to use (pawn, rook, knight, bishop, queen and king)
piecetypenames=('pawn','rook','knight','bishop','queen','king') ; the names of the piece (types)
ranges=(8..1,1..8) ; display ranges
colors=(231,16) ; the (foreground) color of the pieces
bgcolors=(247,251) ; the field colors
shadowcolors=(250,248) ; the gray next to the field colors
; initialize the game
rows='12345678' ; the row names
cols='abcdefgh' ; the column names
movecount=0
enpassantcols=(?,?) ; keep track of the en passant capture positions (which is always the position behind a two-step pawn movement)
playerincheck=0 ; the player currently in check
playerindex=1 ; current player
; keep track of the positions of all pieces (by player, by type)
; if we always store the position of the king in the first element, it's easy to find
; and the nearest rook in the second position, and the farthest rook in the third position to make it easy to check whether they moved
piecepositions=(
  ((6,1,5,0),(2,1,1,0),(2,1,8,0),(3,1,2,0),(4,1,3,0),(5,1,4,0),(4,1,6,0),(3,1,7,0),(1,2,1,0),(1,2,2,0),(1,2,3,0),(1,2,4,0),(1,2,5,0),(1,2,6,0),(1,2,7,0),(1,2,8,0)),
  ((6,8,5,0),(2,8,1,0),(2,8,8,0),(3,8,2,0),(4,8,3,0),(5,8,4,0),(4,8,6,0),(3,8,7,0),(1,7,1,0),(1,7,2,0),(1,7,3,0),(1,7,4,0),(1,7,5,0),(1,7,6,0),(1,7,7,0),(1,7,8,0))
  )
; put the pieces on the board
board=replicate(replicate(0,8),8) ; create empty board
for(pi,(1,2),ppps=piecepositions(pi),for(ppi,1..len(ppps),pps=ppps(ppi),board(pps(2),pps(3))=if(pi==1,pps(1),-pps(1))))
; initialize check pieces (the positions on the board from where pieces can give check)
; NOTE that at the start of the game there are no check fields
checkpieces=? ; initialize
incheckinfo=? ; initialize
updateCheckPieces() ; collect (in) check information
; show chess board in the orientation of the current player
showBoard()
; determine all valid moves the current player can do
validmoves=getValidPlayerMoves(playerindex)
out("Valid moves: ",validmoves)
; ask the user for his/her move
; determine the list of pieces the current player still has (requires #validmoves)
(ppts='',ppps=piecepositions(playerindex))
for(ppi,1..len(ppps),ppt=piecetypes(ppps(ppi,1)),if(and(find(ppt,ppts)==0,len(validmoves(ppi))>0),ppts+=ppt))
out(if(playerindex==1,player1,player2)+', what piece do you want to move ['+ppts+']? ')
piecetype=inch(ppts) ; get one of the player pieces characters
out(if(defined(piecetype),piecetype,'?'),lf)
if(undefined(piecetype),if(givingUp(),debug=debugnow,return(3-playerindex),jump(-2))) ; if no piece defined, ask the user if they want to give up
; get the position of this piece, if multiple positions exist, ask the user which one he means, there can be at most 8 of them (pawns), which we may number
piecetypeindex=find(piecetype,piecetypes) ; the piece index is the position of the piece (type)
pieceindex=getPieceToMove(piecetypeindex) ; returns the index of the piece to move (so piecepositions(pieceindex,piecetomove) is the start position)
; ask for the destination position
(out("What column to move to? "),tocol=inch(cols),out(lf))
(out("What row to move to? "),torow=inch(rows),out(lf))
; is this a registered move?
;;; execute the move
movecount+=1
updateInCheck() ; check whether the opponent is now in check
if(playerincheck>0&&checkMate(),debug=debugnow,return(playerindex)) ; if opponent in check, check for checkmate
playerindex=3-playerindex
jump(-21)
