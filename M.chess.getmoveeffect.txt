; getMoveEffect() checks whether or not the move from #fromrow,#fromcol to #torow,#tocol is valid
; assumes that the piece at (fromrow,fromcol) can actually be moved to (torow,tocol)
; fifth argument #movetype indicates what type of move it is:
; -1=black en passant capture, 1=white en passant capture, 2=short castling, 3=long castling, 0=normal
; returns -1 if an invalid move, 0 if normal move, 1 if it results in the opponent in check
; returns 2 if opponent can not move but not in check, 3 if both i.e. mate
; NOTE most of the code is similar to that of isAValidMove() except we have to assess
;      the effect of the move as well, not just whether or not it is valid
$=-1
; normal move execution
(piece=board(fromrow,fromcol),psign=sign(piece),captured=board(torow,tocol),board(torow,tocol)=piece,board(fromrow,fromcol)=0)
; additional things we need to do depending on the move type (when 0 nothing is done!)
select(abs(movetype),
      ,board(torow+movetype,tocol)=0
      ,(board(torow,6)=board(torow,8),board(torow,8)=0)
      ,(board(torow,4)=board(torow,1),board(torow,1)=0)
      )
(player=if(psign>0,1,2),krow=piecepositions(player,1,2),kcol=piecepositions(player,1,3)) ; the 'before' move king position
if(and(krow==fromrow,kcol==fromcol),(krow=torow,kcol=tocol)) ; if this move moves the king pass along the new king position
; if the move does not result in the king being in check (at #krow,#kcol), determine if opponent in check and/or whether can move
if(attacks(-psign,krow,kcol)==0
  ,$=attacks(psign,pieceposition(3-player,1,2),piecepositions(3-player,1,3))
    +if(playerCanMove(3-player,torow+if(abs(movetype)==1,movetype,0),tocol),2,0)
  )
; normal move undo
(board(fromrow,fromcol)=piece,board(torow,tocol)=captured)
; additional undoes for special moves (en passant captures, short and long castling)
select(abs(movetype),
      ,board(torow+movetype,tocol)=movetype
      ,(board(torow,8)=board(torow,6),board(torow,6)=0)
      ,(board(torow,1)=board(torow,4),board(torow,4)=0)
      )
